Работа с директориями
###################################################

:date: 2022-05-14
:summary: работа с директориями 
:status: published
:author: Соседская Е.О

.. default-role:: code
.. contents:: Содержание


Введение
===========

Bash (Bourne Again Shell) — это командная оболочка, использующаяся в таких UNIX-системах, как Linux или MacOS. Она позволяет управлять компонентами ОС с помощью определённых запросов, которые вводятся в консоль или берутся из скрипта.
 

Работа с файлами и каталогами в Linux через Bash осуществляется с учетом иерархического принципа их классификации. Иерархическая структура файловой системы Linux напоминает «дерево». Существует корневой каталог, который является начальным для всей ОС, а в нём, соответственно, масса других подкаталогов.

Такой же принцип используется для командной строки. Файлы и каталоги берут начало из корневого узла «/», который является начальной точкой для всех элементов. В Linux есть набор стандартных каталогов, которые унифицированы согласно стандарту FHS (Filesystem Hierarchy Standard). Ознакомимся с основными:

.. image:: https://1.bp.blogspot.com/-0WC0BHGdhPk/X6wkm3usGsI/AAAAAAAAAGE/xK31-rV8twwe9YulQ0CvStDRGC1y0KBfgCLcBGAsYHQ/s950/linux-filesystem.png

* ``/bin`` – основные двоичные модули (стандартные утилиты);
* ``/boot`` – содержит конфигурационные файлы загрузчика GRUB, образы ядра и другие вспомогательные файлы загрузчика;
* ``/dev`` – содержит файлы устройств, тут не лишним будет заметить, что в Linux все подключенные устройства представлены в виде файлов и обращение к ним происходит именно через файлы в этом каталоге;
* ``/etc`` – содержит конфигурационные файлы операционной системы и всех сетевых служб, здесь находятся именно общесистемные конфигурационные файлы, а пользовательские конфигурационные файлы находятся в домашнем каталоге каждого пользователя;
* ``/home`` – здесь находятся домашние каталоги всех пользователей, которые зарегистрированы в системе, а именно хранятся пользовательские данные и конфигурационные файлы конкретного пользователя. Обычный пользователь имеет права записи только в своем домашнем каталоге, а чтобы изменять другие файлы в системе нужно иметь права доступа root;
* ``/lib`` – здесь находятся различные библиотеки и модули ядра, именно сюда устанавливаются различные зависимости необходимые для корректной работы приложений;
* ``/lost+found`` – в этот каталог система будет помещать поврежденные файла, в последствии их можно попробовать восстановить;
* ``/media`` – подключаемые носители, при введении в компьютер флешку, в этом каталоге создастся подкаталог с именем тома вашего устройства и используя его можно получить доступ к содержимому устройства;
* ``/mnt`` – в этот каталог можно мониторовать внешние или дополнительные файловые системы
* ``/opt`` – каталог, содержащий вспомогательные пакеты, туда могут устанавливаться дополнительные пакеты программного обеспечения;
* ``/proc`` – содержит файлы с информацией о системе и процессах;
* ``/root`` – домашний каталог пользователя root;
* ``/run`` – в этом каталоге приложения могут хранить вспомогательные файлы, в том числе идентификаторы процессов;
* ``/sbin`` – содержит двоичные файлы, необходимые для администрирования системы;
* ``/srv`` – хранятся данные сервисных служб;
* ``/sys`` – информация о системе;
* ``/tmp`` – временные файлы;
* ``/usr`` – находятся приложения и файлы, используемые пользователями;
* ``/var`` – содержит наиболее часто изменяющиеся файлы, например, хэши программ, файлы системных журналов, временные файлы и т.д.


Работа в терминале
====================

Теперь перейдём непосредственно к работе с каталогами и файлами. Работать с ними мы будем из терминала, потому в Linux без терминала никак. Поэтому давайте разберём наиболее часто используемые команды.


Как понять, что находится в папке? Команда ``ls`` — просмотр содержимого каталога:
-----------------------------------------------------------------------------------


Команда ls позволяет просмотреть содержимое каталога. 

.. code-block:: bash

    $ ls опции /путь/к/папке


Опции команды указывают, как именно и в каком виде нужно выводить информацию на экран, а путь - это та папка, которую нужно отобразить. Рассмотрим основные опции утилиты:

* ``-a`` - отображать все файлы, включая скрытые, это те, перед именем которых стоит точка;
* ``-A`` - не отображать ссылку на текущую папку и корневую папку . и ..;
* ``--author`` - выводить создателя файла в режиме подробного списка;
* ``-b`` - выводить Escape последовательности вместо непечатаемых символов;
* ``--block-size`` - выводить размер каталога или файла в определенной единице измерения, например, мегабайтах, гигабайтах или килобайтах;
* ``-B`` - не выводить резервные копии, их имена начинаются с ~;
* ``-c`` - сортировать файлы по времени модификации или создания, сначала будут выведены новые файлы;
* ``-C`` - выводить колонками;
* ``--color`` - включить цветной режим вывода, автоматически активирована во многих дистрибутивах;
* ``-d`` - выводить только директории, без их содержимого, полезно при рекурсивном выводе;
* ``-D`` - использовать режим вывода, совместимый с Emacs;
* ``-f`` - не сортировать;
* ``-F`` - показывать тип объекта, к каждому объекту будет добавлен один из специализированных символов /=>@|;
* ``--full-time`` - показывать подробную информацию, плюс вся информация о времени в формате ISO;
* ``-g`` - показывать подробную информацию, но кроме владельца файла;
* ``--group-directories-first`` - сначала отображать директории, а уже потом файлы;
* ``-G`` - не выводить имена групп;
* ``-h`` - выводить размеры папок в удобном для чтения формате;
* ``-H`` - открывать символические ссылки при рекурсивном использовании;
* ``--hide`` - не отображать файлы, которые начинаются с указанного символа;
* ``-i`` - отображать номер индекса inode, в которой хранится этот файл;
* ``-l`` - выводить подробный список, в котором будет отображаться владелец, группа, дата создания, размер и другие параметры;
* ``-L`` - для символических ссылок отображать информацию о файле, на который они ссылаются;
* ``-m`` - разделять элементы списка запятой;
* ``-n`` - выводить UID и GID вместо имени и группы пользователя;
* ``-N`` - выводить имена как есть, не обрабатывать контролирующие последовательности;
* ``-Q`` - брать имена папок и файлов в кавычки;
* ``-r`` - обратный порядок сортировки;
* ``-R`` - рекурсивно отображать содержимое поддиректорий;
* ``-s`` - выводить размер файла в блоках;
* ``-S`` - сортировать по размеру, сначала большие;
* ``-t`` - сортировать по времени последней модификации;
* ``-u`` - сортировать по времени последнего доступа;
* ``-U`` - не сортировать;
* ``-X`` - сортировать по алфавиту;
* ``-Z`` - отображать информацию о расширениях SELinux;
* ``-1`` - отображать один файл на одну строку.


Как понять, где находишься? Иногда возникает необходимость увидеть полный путь к каталогу, в котором ты работаешь, для этого используется команда ``pwd``:
--------------------------------------------------------------------------------------------------------------------------------------------------------------

Узнать имя текущей директории вы можете, использовав ``pwd``. Расшифровывается как ``Print Working Directory``. 

.. code-block:: bash

    $ pwd опции


Выглядит это таким образом:

.. code-block:: bash

    $ pwd /home/a/newdirectory


Как перейти в другую директорию? Команда ``cd`` — она позволяет перемещаться между каталогами:
------------------------------------------------------------------------------------------------

.. code-block:: bash

    $ cd опции папка_назначения

Рассмотрим некоторые опции данной команды:

``d /home/user``-	перейти в указанный каталог

``cd /`` -	перейти корневой каталог

``cd`` - перейти в домашний каталог текущего пользователя

``cd ../..`` - перейти в каталог на два уровня выше

``cd –`` - перейти в каталог в котором находился до перехода в текущий

Путь может быть абсолютным или относительным.

По абсолютному пути
~~~~~~~~~~~~~~~~~~~~~~~

Либо у вас где-то записан путь, «куда идти», либо вы подсмотрели его в графическом интерфейсе (например, в WinSCP).

Вставляем путь в командную строку после ``cd``:

.. code-block:: bash

    $ cd /home/student/log


Мы переместились из домашней директории (обозначается как ~) в /home/student/log.


По относительному пути
~~~~~~~~~~~~~~~~~~~~~~~

Относительный путь — относительно вашей текущей директории, где вы сейчас находитесь. Если я уже нахожусь в /home/student, а мне надо в /home/student/log, команда будет такой:

.. code-block:: bash

    $ cd log -- перейти в папку log из той директории, где вы сейчас находитесь


Если мне из надо из /home/student/photo в /home/student/photo/city/msk/2017/cat_1, команда будет такой:

.. code-block:: bash

    $ cd city/msk/2017/cat_1


Что же касается работы с файлами, то она заключается в трёх простых действиях:
---------------------------------------------------------------------------------


* копирование;

* перемещение;

* удаление

Просто пропишите команду и полное имя файла вместе с его расширением, над которым вы хотите произвести какое-либо действие. Например:

.. code-block:: bash

    $ cp file1.bkp


Чтобы создать новый каталог, нужно воспользоваться командой ``mkdir`` и указать название нового каталога:
----------------------------------------------------------------------------------------------------------

(не забывайте, что вы можете создавать новые каталоги только внутри папки, в которой у вас есть права на запись):

.. code-block:: bash

    $ mkdir


``mkdir newfolder`` - создаст каталог с именем newfolder


``mkdir new new1`` - создаст два каталога с именами new и new1


``mkdir -p new/new1/new2`` - создаст указанное дерево директорий


Как создать файл? Команда ``touch``:
--------------------------------------

.. code-block:: bash

    $ touch app.log


Такая команда создаст пустой файл с названием «app.log». А потом уже можно открыть файл в редакторе и редактировать. 

Как удалить файл? Команда ``rm (remove)``:
--------------------------------------------

.. code-block:: bash

    $ rm

``rm file1`` - удалить file1


``rm -r folder1`` - удалить каталог folder1


``rm *`` - удалить все файлы в текущей директории


``rm -rf test_folder`` - Если вы чистите много файлов, то на каждый система переспрашивает, и надо постоянно отвечать «да, да, да...» (y – enter, y – enter, y – enter)… Этот флаг, чтобы удалить все без вопросов, используйте флаг ``-f (force)``


``rm -rfv test_folder`` - удалит папку со всем содержимым, но выведет имена удаляемых файлов


    *Примечание*: если вы пытаетесь удалить файлы, которые уже используются в программе или доступны только для чтения, система будет переспрашивать


Как переместить файл? ``Команда mv (move)``:
---------------------------------------------

.. code-block:: bash

    $ mv


``mv file1 newname`` - переименовать файл (каталог) file1 в newname
``mv file1 folder1`` - переместить файл file1 в каталог folder2
``mv folder1 folder2`` - переместить каталог folder1 в каталог folder2

Можно сразу переименовать файл:

.. code-block:: bash

    $ mv app.log /home/olga/app_2020_03_08.log


Тут мы перенесли log в /home/olga и переименовали


Как копировать файл? Команда ``cp (copy)``:
-------------------------------------------

.. code-block:: bash

    $ cp что_копировать куда_копировать
        
	
``cp file1 file2`` - скопировать файл file1 в файл file2 (если файлы не в текущем каталоге
необходимо указывать полный путь к файлам

``cp file1 /home/user1/`` - скопировать файл file1 в каталог user1

``cp -r folder1 folder2`` - скопировать каталог folder1 в каталог folder2 (если каталога folder2 не существует он будет создан) (folder1/2 это полный путь к каталогу)


Можно сразу переименовать файл:

.. code-block:: bash

    $ cp app.log /home/olga/app_test_2020_03_08.log


В этом случае мы взяли app.log и поместили его в папку /home/olga, переименовав при этом в app_test_2020_03_08.log. Мало ли, сколько логов у вас в этом папке уже лежит, чтобы различать их, можно давать файлу более говорящее имя.

Если в «куда копировать» файл с таким именем уже есть, система не будет ничего спрашивать, просто перезапишет его. 

Просмотр содержимого файлов с помощью команды ``cat`` :
--------------------------------

.. code-block:: bash

    $ cat

``cat file1`` - показать содержимое файла file1 в терминале

``tac file1`` - показать содержимое файла file1 в терминале начиная с конца

``less file1`` - показать содержимое файла file1 в терминале, постранично, с возможно листать страницы

Использование ссылок: команда ``ln``:
-------------------------------------------

Символические и жесткие ссылки - это особенность файловой системы Linux, которая позволяет размещать один и тот же файл в нескольких директориях. В Linux существует два типа ссылок на файлы. Это символические и жесткие ссылки Linux. 

Символические ссылки более всего похожи на обычные ярлыки. Они содержат адрес нужного файла в вашей файловой системе. Когда вы пытаетесь открыть такую ссылку, то открывается целевой файл или папка. Главное ее отличие от жестких ссылок в том, что при удалении целевого файла ссылка останется, но она будет указывать в никуда, поскольку файла на самом деле больше нет.

Вот основные особенности символических ссылок:

* Могут ссылаться на файлы и каталоги;
* После удаления, перемещения или переименования файла становятся недействительными;
* Права доступа отличаются от исходного файла;
* При изменении прав доступа для исходного файла, права на ссылку останутся неизменными;
* Можно ссылаться на другие разделы диска;
* Содержат только имя файла, а не его содержимое.

Жесткие ссылки реализованы на более низком уровне файловой системы. Файл размещен только в определенном месте жесткого диска. Но на это место могут ссылаться несколько ссылок из файловой системы. Каждая из ссылок - это отдельный файл, но ведут они к одному участку жесткого диска. Файл можно перемещать между каталогами, и все ссылки останутся рабочими, поскольку для них неважно имя. Рассмотрим особенности:

* Работают только в пределах одной файловой системы;
* Нельзя ссылаться на каталоги;
* Имеют тот же набор разрешений что и у исходного файла;
* Разрешения на ссылку изменяться при изменении разрешений файла;
* Можно перемещать и переименовывать и даже удалять файл без вреда ссылке.

Жесткие ссылки жестко привязываются к файлу - вы не можете удалить файл, пока на него указывает хотя бы одна жесткая ссылка. А вот если на файл указывают символические ссылки, его удалению ничто не помешает.

Для создания символических и жестких ссылок существует утилита ln:

.. code-block:: bash

    $ ln опции файл_источник файл_ссылки


*Рассмотрим опции утилиты:* 
* ``-d`` - разрешить создавать жесткие ссылки для директорий суперпользователю;
* ``-f`` - удалять существующие ссылки;
* ``-i`` - спрашивать нужно ли удалять существующие ссылки;
* ``-P`` - создать жесткую ссылку;
* ``-r`` - создать символическую ссылку с относительным путем к файлу;
* ``-s`` - создать символическую ссылку.

Нужна помощь? Команда ``man``:
-------------------------------

Команда man позволяет получить доступ к общей базе справки по команде, функции или программе. Обычно для просмотра справки программе надо передать название команды или другого объекта в системе. Это интерфейс, используемый для просмотра справочных руководств системы, отсюда и название: man - сокращение от manual.

.. code-block:: bash

    $ man раздел название_страницы


Обычно название страницы совпадает с именем команды или названием программы. Вся справка разделена на несколько разделов.

Каждая страница справки разделена на несколько секций. Вы можете видеть их на снимках экрана выше. Это:
	
* NAME - имя программы или команды, а также краткое её описание;
* SYNOPSIS - синтаксис команды и порядок передачи в неё опций;
* DESCRIPTION - более подробное описание команды;
* CONFIGURATION - настройки программы;
* OPTIONS - опции команды;
* EXAMPLE - примеры использования;
* AUTHORS - авторы программы.

Конечно, существуют и другие разделы, но эти самые основные. Если информации про утилиту мало, то некоторые разделы могут быть объединены вместе, а некоторых может и вовсе не быть.

Для просмотра информации и управлением страницей справки используются такие горячие клавиши:

* ``стрелка вверх/вниз`` - прокрутка информации вверх или вниз;
* ``e или j`` - переместиться на одну строку вверх;
* ``y или h`` - переместиться на одну строку вниз;
* ``z`` - переместиться на одно окно вниз;
* ``w`` - переместиться на одно окно вверх;
* ``d`` - переместиться на пол окна вниз;
* ``u`` - переместиться на пол окна вверх;
* ``/`` - поиск вхождений указанных после символов вперед;
* ``?`` - то же самое, что и предыдущее, только поиск назад;
* ``n`` - в режиме поиска отображение следующего вхождения;
* ``N`` - в режиме поиска отображение предыдущего вхождения.


Для того, чтобы искать какое-либо слово на странице, нажмите клавишу / и начните набирать слово, которое надо искать. Оно будет отображаться внизу окна. Затем нажмите Enter и программа подсветит все вхождения этого слова в текст. Для поиска следующего вхождения нажимайте n.

Рассмотрим некоторые опции команды ``man``:

* ``-f`` - позволяет посмотреть краткое описание справочной страницы,
* ``-k`` - можно выполнять поиск по кратким описаниям справочных страниц,
* ``-K`` - позволяет выполнять поиск по самим справочным страницам,
* ``-L`` - позволяет вручную задать язык, на котором будет отображена страница.

Для вывода информации про man на английском выполните: *man -L en_US man*, чтобы отобразить man на русском Linux надо передать этой опции значение ru_RU: *man -L ru_RU man*.

Команда ``head`` для вывода начальных строк файла:
---------------------------------------------------------------------------------

Команда *head* выводит начальные строки (по умолчанию — 10)  из одного или нескольких документов. Также она может показывать данные, которые передает на вывод другая утилита.

.. code-block:: bash

    $ head опции файл


Чаще всего к команде ``head`` применяются такие опции:


* ``-n (--lines)`` — показывает заданное количество строк вместо 10, которые выводятся по умолчанию. Если записать эту опцию в виде --lines=[-]NUM, будет показан весь текст кроме последних NUM строк.

    Не будем забывать об еще одном интересном свойстве этой опции. Она позволяет вывести то количество строк, которое останется после «отсечения» лишнего текста. Для этого нужно использовать не сокращенную (однобуквенную), а полную запись опции: ``$ head --lines=[-]NUM``

    Во время работы в терминале квадратные скобки не используются, знак минуса идет сразу же после знака равно.

    Следует заметить, что строки «отсекаются», начиная с последней.

* ``-c (--bytes)`` — позволяет задавать количество текста не в строках, а в байтах. При записи в виде ``--bytes=[-]NUM`` выводит на экран все содержимое файла, кроме NUM байт, расположенных в конце документа.

.. code-block:: bash

    $ head -c NUM file-name.txt



Как и в случае с опцией --lines, можно «отсечь» ненужный объем текста, используя полную форму опции ``-с — --bytes``. Запись команды проводится по тому же принципу и лишние байты тоже отсчитываются, начиная с конца документа:

.. code-block:: bash

    $ head --bytes=[-]NUM


При записи байт можно использовать буквенные суффиксы:
    * b — умножает число на 512.

    * kB — на 1000.
    * k — на 1024.
    * MB — на 1 000 000.
    * M — на 1 048 576.

  
    * ``-q (--quiet, --silent)`` — выводит только текст, не добавляя к нему название файла.
    * ``-v (--verbose)`` — перед текстом выводит название файла.
    * ``-z (--zero-terminated)`` — символы перехода на новую строку заменяет символами завершения строк.


Переменная NUM, упомянутая выше — это любое число от 0 до бесконечности, задаваемое пользователем. Оно может быть обычным либо содержать в себе множитель.

Команда ``tail`` для краткого просмотра конца файлов:
---------------------------------------------------------------------------------

Все знают о команде cat, которая используется для просмотра содержимого файлов. Но в некоторых случаях вам не нужно смотреть весь файл, иногда достаточно посмотреть только то, что находится в конце файла. Например, когда вы хотите посмотреть содержимое лог файла, то вам не нужно то, с чего он начинается, вам будет достаточно последних сообщений об ошибках.

Для этого можно использовать команду *tail*, она позволяет выводить заданное количество строк с конца файла, а также выводить новые строки в интерактивном режиме.

.. code-block:: bash

    $ tail опции файл


По умолчанию утилита выводит десять последних строк из файла, но ее поведение можно настроить с помощью опций:

* ``-c`` - выводить указанное количество байт с конца файла;
* ``-f`` - обновлять информацию по мере появления новых строк в файле;
* ``-n`` - выводить указанное количество строк из конца файла;
* ``--pid`` - используется с опцией -f, позволяет завершить работу утилиты, когда завершится указанный процесс;
* ``-q`` - не выводить имена файлов;
* ``--retry`` - повторять попытки открыть файл, если он недоступен;
* ``-v`` - выводить подробную информацию о файле;
* В качестве значения параметра ``-c`` можно использовать число с приставкой b, kB, K, MB, M, GB, G T, P, E, Z, Y. 
* ``-s`` - задать частоту обновления файла. По умолчанию данные обновляются раз в секунду, но вы можете настроить, например, обновление раз в пять секунд.
